//! File Generation and Output Management
//!
//! This module handles generating Rust source files from recompiled code
//! and managing project structure.

use anyhow::{Context, Result};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

/// Generate Rust source files from recompiled code.
///
/// # Algorithm
/// 1. Create output directory if it doesn't exist
/// 2. Split code into modules (one per function or logical grouping)
/// 3. Generate main.rs with function dispatcher
/// 4. Generate lib.rs with public API
/// 5. Write all files to disk
///
/// # Arguments
/// * `output_dir` - Directory to write generated files
/// * `code` - Generated Rust code (all functions)
///
/// # Returns
/// `Result<()>` - Success or error
///
/// # Errors
/// Returns error if directory creation or file writing fails
pub fn generate_rust_files(output_dir: &Path, code: &str) -> Result<()> {
    // Create output directory
    fs::create_dir_all(output_dir)
        .with_context(|| format!("Failed to create output directory: {:?}", output_dir))?;
    
    // Generate main source file
    let main_rs = output_dir.join("src").join("main.rs");
    fs::create_dir_all(main_rs.parent().unwrap())?;
    
    let mut main_content = String::new();
    main_content.push_str("//! Recompiled GameCube game\n");
    main_content.push_str("//! Generated by GCRecomp\n\n");
    main_content.push_str("mod recompiled;\n");
    main_content.push_str("use recompiled::*;\n\n");
    main_content.push_str("fn main() {\n");
    main_content.push_str("    println!(\"Recompiled GameCube game starting...\");\n");
    main_content.push_str("    // Initialize runtime\n");
    main_content.push_str("    // Run game\n");
    main_content.push_str("}\n");
    
    fs::write(&main_rs, main_content)
        .with_context(|| format!("Failed to write main.rs: {:?}", main_rs))?;
    
    // Generate recompiled module
    let recompiled_rs = output_dir.join("src").join("recompiled.rs");
    fs::write(&recompiled_rs, code)
        .with_context(|| format!("Failed to write recompiled.rs: {:?}", recompiled_rs))?;
    
    // Generate lib.rs
    let lib_rs = output_dir.join("src").join("lib.rs");
    let mut lib_content = String::new();
    lib_content.push_str("//! Recompiled GameCube game library\n");
    lib_content.push_str("//! Generated by GCRecomp\n\n");
    lib_content.push_str("pub mod recompiled;\n");
    lib_content.push_str("pub use recompiled::*;\n");
    
    fs::write(&lib_rs, lib_content)
        .with_context(|| format!("Failed to write lib.rs: {:?}", lib_rs))?;
    
    log::info!("Generated Rust files in: {:?}", output_dir);
    
    Ok(())
}

/// Update game's Cargo.toml with required dependencies.
///
/// # Algorithm
/// 1. Read existing Cargo.toml (or create new one)
/// 2. Parse dependencies section
/// 3. Add required dependencies (gcrecomp-runtime, log, etc.)
/// 4. Write updated Cargo.toml
///
/// # Arguments
/// * `deps` - List of dependency names to add
///
/// # Returns
/// `Result<()>` - Success or error
///
/// # Errors
/// Returns error if Cargo.toml read/write fails
pub fn update_game_cargo_toml(deps: &[&str]) -> Result<()> {
    // For now, we'll create a basic Cargo.toml
    // In a full implementation, we'd parse and merge with existing file
    let cargo_toml_content = format!(
        r#"[package]
name = "recompiled-game"
version = "0.1.0"
edition = "2021"

[dependencies]
gcrecomp-runtime = {{ path = "../gcrecomp-runtime" }}
log = "0.4"
anyhow = "1.0"
{}
"#,
        deps.iter()
            .map(|dep| format!("{} = \"*\"", dep))
            .collect::<Vec<_>>()
            .join("\n")
    );
    
    // This would be called from the game directory
    // For now, we'll just log what would be written
    log::info!("Would update Cargo.toml with dependencies: {:?}", deps);
    
    Ok(())
}

